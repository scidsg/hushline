import * as openpgp from "./../../node_modules/openpgp/dist/openpgp.mjs";

function assertClientCryptoSupport() {
  // OpenPGP.js v6 requires secure context + SubtleCrypto + Web Streams + BigInt.
  if (!window.isSecureContext) {
    throw new Error("Encryption requires a secure browser context (HTTPS).");
  }
  if (!window.crypto || !window.crypto.subtle) {
    throw new Error("Encryption requires Web Crypto support in this browser.");
  }
  if (typeof window.ReadableStream === "undefined") {
    throw new Error("Encryption requires Web Streams support in this browser.");
  }
  if (typeof BigInt === "undefined") {
    throw new Error("Encryption requires BigInt support in this browser.");
  }
  if (
    typeof openpgp === "undefined" ||
    typeof openpgp.readKey !== "function" ||
    typeof openpgp.createMessage !== "function" ||
    typeof openpgp.encrypt !== "function"
  ) {
    throw new Error("Encryption module failed to initialize.");
  }
}

function getDicewareWords() {
  const words = window.DICEWARE_WORDS;
  if (!Array.isArray(words) || words.length === 0) {
    throw new Error("Encryption padding dictionary is unavailable.");
  }
  return words;
}

function addPadding(value, blockSize = 512) {
  /**
   * To hide what field is being encrypted, we need to pad the value to a (roughly) fixed block size.
   * This function is used to create a padded version of the field by adding random words at the end until it
   * reaches a multiple of 512-character blocks.
   */

  value += "\n\n(Random text generated by Hush Line: lorum ipsum ";

  // Add padding words
  const dicewareWords = getDicewareWords();
  const targetLen = blockSize - (value.length % blockSize);
  let padding = "";
  while (padding.length < targetLen) {
    padding +=
      dicewareWords[Math.floor(Math.random() * dicewareWords.length)] + " ";
  }
  padding += ")";

  // Return the padded value
  return value + padding;
}

async function encryptMessage(publicKeyArmored, message) {
  if (!publicKeyArmored) {
    console.log(
      "Public key not provided for encryption. Encryption cannot proceed.",
    );
    return false;
  }

  try {
    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });
    const messageText = await openpgp.createMessage({ text: message });
    const encryptedMessage = await openpgp.encrypt({
      message: messageText,
      encryptionKeys: publicKey,
    });
    return encryptedMessage;
  } catch (error) {
    console.error("Error encrypting:", error);
    return false;
  }
}

function isArmoredMessage(value) {
  return (
    typeof value === "string" &&
    value.includes("-----BEGIN PGP MESSAGE-----") &&
    value.includes("-----END PGP MESSAGE-----")
  );
}

function getFieldValue(field) {
  if (
    field.tagName === "INPUT" ||
    field.tagName === "SELECT" ||
    field.tagName === "TEXTAREA"
  ) {
    return field.value;
  } else if (field.tagName === "UL") {
    const checkedValues = [];
    field
      .querySelectorAll(
        "input[type='checkbox']:checked, input[type='radio']:checked",
      )
      .forEach((input) => {
        checkedValues.push(input.value);
      });
    return checkedValues.join(", ");
  }
}

function getFieldLabel(field) {
  return field.getAttribute("data-label");
}

document.addEventListener("DOMContentLoaded", function () {
  const form = document.getElementById("messageForm");
  if (!form) {
    return;
  }
  const publicKeyArmored = document.getElementById("publicKey")
    ? document.getElementById("publicKey").value
    : "";

  form.addEventListener("submit", async function (event) {
    event.preventDefault();
    if (form.dataset.encryptionInProgress === "true") {
      return;
    }

    form.dataset.encryptionInProgress = "true";
    const submitButtons = form.querySelectorAll("button[type='submit'], input[type='submit']");
    submitButtons.forEach((button) => {
      button.disabled = true;
    });

    try {
      assertClientCryptoSupport();

      // Build an email body with all fields, encrypt it, and add it to the DOM as a hidden field
      let emailBody = "";
      document.querySelectorAll(".form-field").forEach((field) => {
        const value = getFieldValue(field);
        const label = getFieldLabel(field);
        if (isArmoredMessage(value)) {
          throw new Error("Message appears already encrypted.");
        }
        emailBody += `# ${label}\n\n${value}\n\n====================\n\n`;
      });
      const encryptedEmailBody = await encryptMessage(
        publicKeyArmored,
        emailBody,
      );
      if (encryptedEmailBody) {
        const encryptedEmailBodyEl = document.getElementById("encrypted_email_body");
        if (!encryptedEmailBodyEl) {
          throw new Error("Encrypted email body field is missing.");
        }
        encryptedEmailBodyEl.value = encryptedEmailBody;
      } else {
        throw new Error("Client-side encryption failed for email body");
      }

      // Loop through all encrypted fields and encrypt them
      const encryptionPromises = Array.from(
        document.querySelectorAll(".encrypted-field"),
      ).map(async (field) => {
        const value = getFieldValue(field);
        if (isArmoredMessage(value)) {
          throw new Error("Message appears already encrypted.");
        }

        const paddedValue = addPadding(value);
        const encryptedValue = await encryptMessage(
          publicKeyArmored,
          paddedValue,
        );
        if (encryptedValue) {
          // Replace the field with a hidden field and a disabled textarea (for show) containing the encrypted value
          let fieldName;
          if (field.tagName === "UL") {
            fieldName = field.querySelector("input").name;
          } else {
            fieldName = field.name;
          }

          // Empty out the field
          const fieldContainer = field.parentElement;
          fieldContainer.innerHTML = "";

          // Add a textarea with the encrypted value
          const hiddenInput = document.createElement("input");
          hiddenInput.type = "hidden";
          hiddenInput.name = fieldName;
          hiddenInput.value = encryptedValue;

          const textarea = document.createElement("textarea");
          textarea.disabled = true;
          textarea.value = encryptedValue;

          fieldContainer.appendChild(hiddenInput);
          fieldContainer.appendChild(textarea);
        } else {
          throw new Error(
            `Client-side encryption failed for field: ${field.name || "unknown"}`,
          );
        }
      });

      // Wait for all encryption operations to complete before submitting
      await Promise.all(encryptionPromises);
      form.submit();
    } catch (error) {
      console.error("Encryption error:", error);
      alert(
        "Message encryption failed. Your message was NOT submitted for security reasons. Please try again.",
      );
      form.dataset.encryptionInProgress = "false";
      submitButtons.forEach((button) => {
        button.disabled = false;
      });
    }
  });
});
